# leetcode 刷题笔记

## 数据结构

## O(1) 操作

1. 如何删除链表中指针指定节点？将其值与下一个节点的值交换，删除下一个
2. 如何删除数组中索引指定元素？将其值与数组最后一个元素值交换，删除最后一个

### 单调栈

单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element

[单调栈结构解决三道算法题](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/dan-tiao-zhan)
[补充例题](https://github.com/jiebaomaster/kaoyan/blob/master/data_structure/monotonyStack.cpp)

扩展：单调栈的单调性还可以用来保证子串的最小字典序

### 二分法

二分法通常以应用题的形式出现，求某个限定条件 t 下的最值，且限定条件和所求值之间存在单调函数关系。通常将所求值 x 当做自变量，限定条件作为因变量，建立函数关系 f(x)，根据 f(x) 与 t 的关系进行二分查找，寻找最值。其中，要查找的 x 的范围通常不会直接给出，需要根据题目条件获取，通常和题目直接给出的数组有关（元素的最值，所有元素的和等）。

### 双指针法

**快慢指针** 如果要操作的节点有明确的位置关系（中位数，倒数第 n 个），可以考虑快慢指针，如快指针先走 n 步，快指针一次走 2 步。快慢指针也用于列表中一次遍历原地去重，删除目标元素。
**左右指针** 如果列表有序，可以考虑左右指针。
**滑动窗口** 左右指针的一种应用，通常用于在 O(n) 时间内求字符串子串相关问题。

``` c++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
  unordered_map<char, int> need,  // 可选，目标子串 t 的元素出现的次数
                          window; // 窗口内元素出现的次数
  for (char c : t) need[c]++;     // 用目标字符串初始化 need

  int left = 0, right = 0;
  int valid = 0; // 可选，记录窗口中有几个元素满足要求了
  while (right < s.size()) {
    // c 是将移入窗口的字符，右移窗口
    char c = s[right++];
    // 进行窗口内数据的一系列更新
    ...

    // 判断左侧窗口是否要收缩，滑动窗口需要保持题目要求的某种状态
    while (window needs shrink) {
      // d 是将移出窗口的字符，左移窗口
      char d = s[left++];
      // 进行窗口内数据的一系列更新
      ...
    }
  }
}
```

## 动态规划

dp定义

遍历顺序

### 子序列问题

- 两个字符串 dp[i][j]，表示以 s1[i] 和 s2[j] 结尾的...
- 一个字符串通常 dp[i]，表示以 s[i] 结尾的...
  - 如果涉及到两个字符的位置如回文，可以设 dp[i][j], 表示子串s[i...j]的...


## 贪心

### 区间问题

区间问题肯定按照区间的起点或者终点进行 **排序**
所有区间问题类型：

1. **最多不重叠区间** 只有一个会议室，还有若干会议，如何将尽可能多的会议安排到这个会议室里？问最多能开几个会议
   - 原型：一个区间列表，在某个范围内从列表中选择最多的区间，要求所选区间不重叠
   - 解法：将这些会议（区间）按结束时间（右端点）升序排序，贪心选择结束时间最早的。[435.无重叠区间](./贪心/区间问题/435.无重叠区间.cpp) [452.用最少数量的箭引爆气球](./贪心/区间问题/452.用最少数量的箭引爆气球.cpp)
2. **短区间拼接长区间** 给你若干较短的视频片段，和一个较长的视频片段，请你从较短的片段中尽可能少地挑出一些片段，拼接出较长的这个片段，求最少需要的短视频片段数量
   - 原型：一个区间列表，在其中选择区间拼接成大区间，要求选中的区间必须数值连续（即部分重叠）
   - 解法：将这些视频片段（区间）按开始时间（左端点）排序，贪心选择连续且结束时间最晚的。[1024.视频拼接](./贪心/区间问题/1024.视频拼接.cpp)
3. **区间合并** 给你若干区间，请你将所有有重叠部分的区间进行合并，求合并后的区间列表
   - 将这些区间按起点升序终点降序排序，遍历与前一个区间比较，合并交叉的。[56.合并区间](./贪心/区间问题/56.合并区间.cpp)
4. **删除被覆盖区间** 给你若干区间，其中可能有些区间比较短，被其他区间完全覆盖住了，请你删除这些被覆盖的区间，求剩余区间数量
   - 参照上一题的思路，将这些区间按起点升序终点降序排序，遍历与前一个区间比较，依次合并交叉并删除被覆盖，注意这里的合并只是逻辑合并，方便判断覆盖，不影响区间数量。[1288.删除被覆盖区间](./贪心/区间问题/1288.删除被覆盖区间.cpp)
5. **两个区间列表的交集** 有两个部门同时预约了同一个会议室的若干时间段，请你计算会议室的冲突时段。
   - 原型：两个区间列表，列表内区间不重叠，求两个列表间的区间交集
   - 解法：将这些区间按起点升序排序，双指针依次遍历两个列表，求区间交集。[986.区间列表的交集](./贪心/区间问题/986.区间列表的交集.cpp)
6. **区间重叠** 给你输入若干形如 [begin, end] 的区间，代表若干会议的开始时间和结束时间，请你计算至少需要申请多少间会议室。
   - 原型：一个区间列表，求同一时刻 **最多** 有几个区间重叠
   - 解法：将起点和终点都投影到时间轴上，遍历所有时间点，遇到起点就+1，遇到终点就-1。[253.会议室II](./贪心/区间问题/253.会议室II.cpp)
